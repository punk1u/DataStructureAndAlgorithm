package tech.punklu.algorithm.sort;

/**
 * 插入排序
 *
 * 将数组中的数据分为两个区间，已排序区间和未排序区间。
 * 初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，
 * 在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，
 * 直到未排序区间中元素为空，算法结束。
 *
 * 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。
 * 如果要排序的数据已经是有序的，并不需要搬移任何数据。如果从尾到头在有序数据组里面查找插入位置，
 * 每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这里是从尾到头遍历已经有序的数据。
 *
 * 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为O(n^2)。
 *
 * 在数组中插入一个数据的平均时间复杂度是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n^2)。
 *
 *
 */
public class InsertionSort {


    public static void insertionSort(int[] a, int n) {
        if (n <= 1) return;

        /**
         * i一直是未排序区的第一个元素的下标
         */
        for (int i = 1; i < n; ++i) {
            /**
             * 未排序区第一个元素的值
             */
            int value = a[i];
            /**
             * j是已排序区最后一个元素的下标
             */
            int j = i - 1;
            /**
             * 查找插入的位置
             * 从已排序区最后一个元素向前遍历所有已排序过的元素，
             * 找到当前未排序区第一个元素应该放在什么地方。
             * 如果正在遍历的已排序区中的元素大于要当前要插入的未排序区的第一个元素，
             * 将正在遍历的已排序区元素向后诺一位，再继续遍历，否则说明找到了要插入的地方
             */
            for (; j >= 0; --j) {
                if (a[j] > value) {
                    /**
                     * 数据移动
                     * 因为当前正在遍历的已排序区的元素大于要插入的元素，
                     * 将当前正在遍历的已排序区的元素向后挪一位，再继续对已排序区元素向前进行遍历，
                     * 直到找到要插入的位置（即正在遍历的已排序区的元素小于要插入的元素）
                     */
                    a[j+1] = a[j];
                } else {
                    break;
                }
            }
            /**
             * 插入数据
             */
            a[j+1] = value;
        }
    }

    public static void main(String[] args) {
        int[] a = {6,5,4,3,2,1};
        insertionSort(a,6);
        for (int i = 0; i < a.length; i++) {
            System.out.println(a[i]);
        }
    }
}
